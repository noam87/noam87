<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Elixir on Noam&#39;s Website About Software</title>
    <link>http://noamswebsite.com/tags/elixir/index.xml</link>
    <description>Recent content in Elixir on Noam&#39;s Website About Software</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="http://noamswebsite.com/tags/elixir/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Elixir/Erlang Resources</title>
      <link>http://noamswebsite.com/wiki-main/computers/elixir_resources/</link>
      <pubDate>Wed, 04 Jan 2017 16:11:51 -0500</pubDate>
      
      <guid>http://noamswebsite.com/wiki-main/computers/elixir_resources/</guid>
      <description>

&lt;h2 id=&#34;learning&#34;&gt;Learning&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Title&lt;/th&gt;
&lt;th&gt;Notes&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://a.co/hjRDstC&#34;&gt;Elixir In Action&lt;/a&gt; (book)&lt;/td&gt;
&lt;td&gt;My go-to recommendation for getting started with Elixir.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://medium.com/@diamondgfx/introduction-fe138ac6079d&#34;&gt;Writing A Blog Engine in Phoenix&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Great first tutorial for Phoenix framework&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://www.erlang-in-anger.com/&#34;&gt;Erlang In Anger&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Great guide for when stuff goes bad.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;memory-gc&#34;&gt;Memory / GC&lt;/h2&gt;

&lt;p&gt;For articles on GC / compilers in general see &lt;a href=&#34;http://noamswebsite.com/wiki-main/computers/compilers&#34;&gt;compilers&lt;/a&gt; section.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Title&lt;/th&gt;
&lt;th&gt;Notes&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://hamidreza-s.github.io/erlang/scheduling/real-time/preemptive/migration/2016/02/09/erlang-scheduler-details.html&#34;&gt;Erlang Scheduler Details and Why It Matters&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://hamidreza-s.github.io/erlang%20garbage%20collection%20memory%20layout%20soft%20realtime/2015/08/24/erlang-garbage-collection-details-and-why-it-matters.html&#34;&gt;Erlang Garbage Collection Details and Why It Matters&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Simple introduction to Erlang GC concepts. Start here.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://www.erlang-solutions.com/blog/erlang-19-0-garbage-collector.html&#34;&gt;Erlang 19.0 Garbage Collector&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://erlang.org/doc/efficiency_guide/introduction.html&#34;&gt;Erlang Efficiency Guide&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://blog.bugsense.com/post/74179424069/erlang-binary-garbage-collection-a-lovehate&#34;&gt;Erlang Binary Garbage Collection: A love/hate relationship&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Some findings on the shared heap GC.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;concurrency&#34;&gt;Concurrency&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Title&lt;/th&gt;
&lt;th&gt;Notes&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://jlouisramblings.blogspot.ca/2013/01/how-erlang-does-scheduling.html?m=1&#34;&gt;How Erlang does scheduling&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://kth.diva-portal.org/smash/record.jsf?searchId=2&amp;amp;pid=diva2%3A392243&amp;amp;dswid=-8162&#34;&gt;Characterizing the Scalability of Erlang VM on Many-core Processors&lt;/a&gt; (pdf)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;performance&#34;&gt;Performance&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Title&lt;/th&gt;
&lt;th&gt;Notes&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://www.evanmiller.org/elixir-ram-and-the-template-of-doom.html&#34;&gt;Elixir RAM And The Template Of Doom&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://www.bignerdranch.com/blog/elixir-and-io-lists-part-1-building-output-efficiently/&#34;&gt;Elixir and IO Lists, Part 1: Building Output Efficiently&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</description>
    </item>
    
    <item>
      <title>React Resources</title>
      <link>http://noamswebsite.com/wiki-main/computers/react_resources/</link>
      <pubDate>Wed, 04 Jan 2017 14:41:18 -0500</pubDate>
      
      <guid>http://noamswebsite.com/wiki-main/computers/react_resources/</guid>
      <description>&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Title&lt;/th&gt;
&lt;th&gt;Format&lt;/th&gt;
&lt;th&gt;Notes&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://teropa.info/blog/2015/09/10/full-stack-redux-tutorial.html&#34;&gt;A Comprehensive Guide to Test-First Development with Redux, React, and Immutable&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;tutorial&lt;/td&gt;
&lt;td&gt;Great comprehensive introduction to the whole ecosystem.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://youtu.be/-jwQ3sGoiXg&#34;&gt;Redux, Re-fram, Relay, Om/next, oh my!&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;video&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://github.com/absinthe-graphql/absinthe_relay/issues/8&#34;&gt;Setting Up Absinthe Relay In Elixir&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</description>
    </item>
    
    <item>
      <title>Separate Ecto From Phoenix In Umbrella App</title>
      <link>http://noamswebsite.com/wiki-main/computers/phoenix_no_ecto/</link>
      <pubDate>Wed, 04 Jan 2017 00:52:25 -0500</pubDate>
      
      <guid>http://noamswebsite.com/wiki-main/computers/phoenix_no_ecto/</guid>
      <description>

&lt;p&gt;First, create umbrella application:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ mix new --umbrella my_app
$ cd my_app/apps
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next create Phoenix app, excluding Ecto:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ mix phoenix.new web --no-ecto
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we create a new mix project for Ecto, with supervision tree:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ mix new db --sup
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally we need to set up some configuration files.&lt;/p&gt;

&lt;h2 id=&#34;setting-up-db-project&#34;&gt;Setting Up Db Project&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;$ cd db
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;First in the &lt;code&gt;db&lt;/code&gt; project (following the
&lt;a href=&#34;https://hexdocs.pm/ecto/getting-started.html&#34;&gt;getting started&lt;/a&gt; docs for Ecto:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;mix.exs&lt;/code&gt;&lt;/strong&gt; (note that we do not need to register &lt;code&gt;:ecto&lt;/code&gt; application)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  def application do
    [applications: [:logger, :postgrex],
     mod: {Db, []}]
  end

  defp deps do
    [{:postgrex, &amp;quot;~&amp;gt; 0.13.0&amp;quot;},
     {:ecto, &amp;quot;~&amp;gt; 2.1.1&amp;quot;}]
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Run configuration by running:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ mix ecto.gen.repo -r Db.Repo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will populate &lt;code&gt;lib/db/repo.ex&lt;/code&gt; and  &lt;code&gt;config.config.exs&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;lib/db.ex&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;children = [
  supervisor(Db.Repo, [])
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;optional&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;We probably want configs for multiple environments.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;config/config.exs&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Uncomment the last line, or replace the contents of the file with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use Mix.Config

config :db,
  ecto_repos: [Db.Repo]

# Import environment specific config. This must remain at the bottom
# of this file so it overrides the configuration defined above.
import_config &amp;quot;#{Mix.env}.exs&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will load environment-specific configs.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;config/dev.exs&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use Mix.Config

config :db, Db.Repo,
  adapter: Ecto.Adapters.Postgres,
  username: &amp;quot;foo&amp;quot;,
  database: &amp;quot;myproject_dev&amp;quot;,
  hostname: &amp;quot;localhost&amp;quot;,
  pool_size: 10
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;config/test.exs&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use Mix.Config

config :db, Db.Repo,
  adapter: Ecto.Adapters.Postgres,
  username: &amp;quot;foo&amp;quot;,
  password: &amp;quot;12345&amp;quot;,
  database: &amp;quot;myproject_test&amp;quot;,
  hostname: &amp;quot;localhost&amp;quot;,
  pool: Ecto.Adapters.SQL.Sandbox

config :logger,
  backends: [:console],
  compile_time_purge_level: :debug
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;set-up-phoenix-app&#34;&gt;Set Up Phoenix App&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;$ cd ../web
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;mix.exs&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  def application do
    [mod: {Web, []},
     applications: [:phoenix_ecto, :db]]
  end

  defp deps do
    [{:phoenix_ecto, &amp;quot;~&amp;gt; 3.2.1&amp;quot;},
     {:db, in_umbrella: true}]
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;config/config.exs&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;config :web,
  ecto_repos: [Db.Repo]

# Configure phoenix generators
config :phoenix, :generators,
  migration: false
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;notes&#34;&gt;Notes&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;From now on, when running &lt;code&gt;mix phoenix.gen.html&lt;/code&gt; or &lt;code&gt;mix phoenix.gen.json&lt;/code&gt;,
pass the &lt;code&gt;--no-model&lt;/code&gt; option.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Since app is umbrella app now, remember to &lt;code&gt;cd&lt;/code&gt; into phoenix app directory
before running generators, or files will be generated at umbrella&amp;rsquo;s top level.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;questions&#34;&gt;Questions&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Is it there a way to make it so that there&amp;rsquo;s no need for &lt;code&gt;--no-model&lt;/code&gt; option
every time?&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Ecto Callbacks Macro</title>
      <link>http://noamswebsite.com/wiki-main/computers/ecto_callbacks/</link>
      <pubDate>Sat, 22 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>http://noamswebsite.com/wiki-main/computers/ecto_callbacks/</guid>
      <description>

&lt;p&gt;Ecto callbacks (before/after) commit hooks have been deprecated, for a
general good reason. Using callbacks is generally bad and you should never do
it. But sometimes you need to do it because real life.&lt;/p&gt;

&lt;p&gt;I wrote this macro this afternoon that implements both atomic and non-atomic
callbacks. Here it is in all its glory. I won&amp;rsquo;t make it a hex package because
it&amp;rsquo;s probably a bad thing to do.&lt;/p&gt;

&lt;h2 id=&#34;usage&#34;&gt;Usage&lt;/h2&gt;

&lt;p&gt;In your &lt;code&gt;YourProject.Model.ex&lt;/code&gt; file, add:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;defmodule MyProject.Model do
  defmacro __using__(_opts) do
    quote do
      use Ecto.Schema
      import Ecto.Changeset
      use MyProject.Hooks
    end

    @doc &amp;quot;&amp;quot;&amp;quot;
    Dumb. For piping together methods in an `atomic_after_*` function call.

    ## Example

      first_callback()
      |&amp;gt; hook_glue()
      |&amp;gt; second_callback()
    &amp;quot;&amp;quot;&amp;quot;
    def hook_glue({:ok, struct}), do: struct
    def hook_glue(struct), do: struct
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;implementation&#34;&gt;Implementation&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;defmodule MyProject.Hooks do
  @moduledoc &amp;quot;&amp;quot;&amp;quot;
  This module macro defines the following functions within the model,
  delegating to `Repo`, but allowing us to add `after_*` hooks,
  which are no longer supported in Ecto
  (http://blog.plataformatec.com.br/2015/12/ecto-v1-1-released-and-ecto-v2-0-plans/)

      delete,
      delete!,
      delete_all,
      insert,
      insert!,
      insert_all,
      insert_or_update,
      insert_or_update!,
      update,
      update!,
      update_all

  ## Hooks

  `after_*` will perform action after transaction is done.
  `atomic_after_*` will perform action within the same transaction, at the end.

  When using `atomic_after`, make sure to return the resulting struct in
  the success case, in its tuple format `{:ok, res}` or `{:error, error}`.

  The return value of the transaction is what will be returned by the action.

  ## Usage

  Will print console message after updating:

  **NOTE:** Remember to cover general case after.

      defmodule MyModel do
        use MyProject.Model # which calls `use MyProject.Overrides`

        defp after_update(result, changeset) do
          IO.puts(&amp;quot;updating!&amp;quot;)
        end

        defp atomic_after_update(r = {:error, _}, _), do: r
        defp atomic_after_update(res, ch) do
          case OtherModel.get!(1).name do
            &amp;quot;bob&amp;quot; -&amp;gt; Repo.rollback(:cant_update_if_name_is_bob)
            _ -&amp;gt; res
          end
        end

      end

      MyModel.update!(ch)
      # -&amp;gt; &amp;quot;updating!&amp;quot;
      %MyModel{...}
  &amp;quot;&amp;quot;&amp;quot;

  defmacro __using__(_) do
    actions = [:delete,
               :delete!,
               :delete_all,
               :insert,
               :insert!,
               :insert_all,
               :insert_or_update,
               :insert_or_update!,
               :update,
               :update!,
               :update_all]

    # For the love of God, do not touch until this is tested!
    quote do
      alias MyProject.Repo

      unquote do
        Enum.map(actions, fn action -&amp;gt;
          quote do
            def unquote(action)(changeset, opts \\ []) do
              fwd = fn -&amp;gt;
                res = Repo.unquote(action)(changeset, opts)
                after_res = unquote(:&amp;quot;atomic_after_#{action}&amp;quot;)(res, changeset)

                # Handle whether the action is with bang for or not
                unquote do
                  if String.last(Atom.to_string(action)) == &amp;quot;!&amp;quot; do
                    quote do
                      transaction_result =
                        case after_res do
                          {:ok, res} -&amp;gt; res
                          {:error, error} -&amp;gt; raise error
                        end
                    end
                  else
                    quote do
                      transaction_result = after_res
                    end
                  end
                end
                transaction_result
              end

              result =
                case Repo.transaction(fwd) do
                  # Covers e.g insert / update
                  {:ok, {:ok, res}} -&amp;gt; {:ok, res}
                  # Just in case
                  {:ok, {:error, error}} -&amp;gt; {:error, error}
                  # Covers insert! update! which return struct
                  {:ok, res} -&amp;gt; res
                  # Covers rollback which returns error
                  {:error, error} -&amp;gt; {:error, error}
                end

              unquote(:&amp;quot;after_#{action}&amp;quot;)(result, changeset)
              result
            end
          end
        end)
      end

      unquote do
        Enum.map(actions, fn action -&amp;gt;
          quote do
            defp unquote(:&amp;quot;after_#{action}&amp;quot;)(_res, _original_struct), do: nil
          end
        end)
      end

      unquote do
        Enum.map(actions, fn action -&amp;gt;
          if String.last(Atom.to_string(action)) == &amp;quot;!&amp;quot; do
            quote do
              defp unquote(:&amp;quot;atomic_after_#{action}&amp;quot;)(res, _) do
                {:ok, res}
              end
            end
          else
            quote do
              defp unquote(:&amp;quot;atomic_after_#{action}&amp;quot;)(res, _), do: res
            end
          end
        end)
      end

      defoverridable [after_delete: 2,
                      atomic_after_delete: 2,
                      after_delete!: 2,
                      atomic_after_delete!: 2,
                      after_delete_all: 2,
                      atomic_after_delete_all: 2,
                      after_insert: 2,
                      atomic_after_insert: 2,
                      after_insert!: 2,
                      atomic_after_insert!: 2,
                      after_insert_all: 2,
                      atomic_after_insert_all: 2,
                      after_insert_or_update: 2,
                      atomic_after_insert_or_update: 2,
                      after_insert_or_update!: 2,
                      atomic_after_insert_or_update!: 2,
                      after_update: 2,
                      atomic_after_update: 2,
                      after_update!: 2,
                      atomic_after_update!: 2,
                      after_update_all: 2,
                      atomic_after_update_all: 2]
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>