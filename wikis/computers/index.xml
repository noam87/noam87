<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Computers on Noam&#39;s Website About Software</title>
    <link>http://noamswebsite.com/wikis/computers/index.xml</link>
    <description>Recent content in Computers on Noam&#39;s Website About Software</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="http://noamswebsite.com/wikis/computers/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Memory Accessing Alignment</title>
      <link>http://noamswebsite.com/wiki-main/computers/alignment/</link>
      <pubDate>Wed, 12 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>http://noamswebsite.com/wiki-main/computers/alignment/</guid>
      <description>

&lt;p&gt;For any data type that requires &lt;code&gt;N&lt;/code&gt; bytes, its starting address should be a
multiple of &lt;code&gt;N&lt;/code&gt;. In most &lt;code&gt;x86&lt;/code&gt; processors the memory interface is designed to
read/write blocks that are 8 or 16 bytes long&lt;sup&gt;2&lt;/sup&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;Unaligned memory accesses&lt;/em&gt; occur when you try to read &lt;code&gt;N&lt;/code&gt; bytes of data
starting from an address that is not evenly divisible by &lt;code&gt;N&lt;/code&gt; (i.e. &lt;code&gt;addr % N
!= 0&lt;/code&gt;).  For example, reading 4 bytes of data from address &lt;code&gt;0x10004&lt;/code&gt; is fine,
but reading 4 bytes of data from address &lt;code&gt;0x10005&lt;/code&gt; would be an unaligned
memory access &lt;sup&gt;6&lt;/sup&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Unaligned access may allow the program to use less
memory&lt;sup&gt;1&lt;/sup&gt;, but it has many drawbacks:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The effects of performing an unaligned memory access vary from architecture
to architecture. A summary of the common scenarios:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Some architectures are able to perform unaligned memory accesses
transparently, but there is usually a significant performance cost.&lt;/li&gt;
&lt;li&gt;Some architectures raise processor exceptions when unaligned accesses
happen. The exception handler is able to correct the unaligned access, at
significant cost to performance.&lt;/li&gt;
&lt;li&gt;Some architectures raise processor exceptions when unaligned accesses
happen, but the exceptions do not contain enough information for the
unaligned access to be corrected.&lt;/li&gt;
&lt;li&gt;Some architectures are not capable of unaligned memory access, but will
silently perform a different memory access to the one that was requested,
resulting in a subtle code bug that is hard to detect!&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If your code causes unaligned memory accesses to happen, your code will not
work correctly on certain platforms and will cause performance problems on
others &lt;sup&gt;6&lt;/sup&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;example&#34;&gt;Example&lt;/h2&gt;

&lt;p&gt;Consider a bitmap data structure where each pixel is represented by 3 bytes (RGB). In order to preserve alignment we add a &amp;ldquo;padding byte&amp;rdquo;&lt;sup&gt;3&lt;/sup&gt;, making the structure 32 bits instead of 24:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+---------------+---------------+---------------+---------------+
| : : : : : : : | : : : : : : : | : : : : : : : | : : : : : : : |
+---------------+---------------+---------------+---------------+
     Red             Green           Blue            Padding
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This consumes more memory, but is ideally more performant. Of course, YMMV&lt;sup&gt;5&lt;/sup&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;small&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;em&gt;Introduction To ARM Cortex-M Microcontrollers&lt;/em&gt; (5&lt;sup&gt;th&lt;/sup&gt; Ed.), p. 96.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Computer Systems: A Programming Perspective&lt;/em&gt; (2&lt;sup&gt;nd&lt;/sup&gt; Ed.), p. 290.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://youtu.be/hNKU8Jiza2g?t=5m19s&#34;&gt;&lt;em&gt;Handmande Hero, Day 004&lt;/em&gt;&lt;/a&gt; (t. 5:19).&lt;/li&gt;
&lt;li&gt;&lt;em&gt;21&lt;sup&gt;st&lt;/sup&gt; Century C&lt;/em&gt;, (2&lt;sup&gt;nd&lt;/sup&gt; Ed.), p. 137.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://lemire.me/blog/2012/05/31/data-alignment-for-speed-myth-or-reality/&#34;&gt;Data Alignment For Speed: Myth Or Reality?&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.kernel.org/doc/Documentation/unaligned-memory-access.txt&#34;&gt;Kernel.org: Unaligned Memory Access&lt;/a&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;/small&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Cool Articles / Papers</title>
      <link>http://noamswebsite.com/wiki-main/computers/cool_articles/</link>
      <pubDate>Tue, 11 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>http://noamswebsite.com/wiki-main/computers/cool_articles/</guid>
      <description>

&lt;h2 id=&#34;general&#34;&gt;General&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Title&lt;/th&gt;
&lt;th&gt;Format&lt;/th&gt;
&lt;th&gt;Notes&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://viewsourcecode.org/snaptoken/kilo/&#34;&gt;Build Your Own Text Editor&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;HTML&lt;/td&gt;
&lt;td&gt;Really great tutorial (and introduction to C programming and terminal programming).&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://www.cs.unm.edu/~crowley/papers/sds.pdf&#34;&gt;Data Structures For Text Sequences&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;PDF&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Handmade hero&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;https://handmadehero.org/&#34;&gt;YouTube&lt;/a&gt; series&lt;/td&gt;
&lt;td&gt;Dude builds a complete release-quality video game from scratch in minimal subset of C++ before your very eyes.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;crypto&#34;&gt;Crypto&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Title&lt;/th&gt;
&lt;th&gt;Format&lt;/th&gt;
&lt;th&gt;Notes&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Efficient Data Structures for Tamper-Evident Logging&lt;/td&gt;
&lt;td&gt;(&lt;a href=&#34;http://people.cs.vt.edu/danfeng/courses/cs6204/sp10-papers/crosby.pdf&#34;&gt;PDF&lt;/a&gt;)&lt;/td&gt;
&lt;td&gt;Youtube talk &lt;a href=&#34;https://youtu.be/G0tkCxq9OuE&#34;&gt;here&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://blog.bren2010.io/2015/04/07/data-structures.html&#34;&gt;Cryptographic Data Structures&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;HTML&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;compilers&#34;&gt;Compilers&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Title&lt;/th&gt;
&lt;th&gt;Format&lt;/th&gt;
&lt;th&gt;Notes&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://blogs.msdn.microsoft.com/abhinaba/2009/03/02/back-to-basics-generational-garbage-collection/&#34;&gt;Back To Basics: Generational Garbage Collection&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;HTML&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;See also &lt;a href=&#34;http://noamswebsite.com/wiki-main/computers/elixir_resources&#34;&gt;here&lt;/a&gt; for examples with Erlang VM
GC.&lt;/p&gt;

&lt;h2 id=&#34;low-level-programming&#34;&gt;Low Level Programming&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Title&lt;/th&gt;
&lt;th&gt;Format&lt;/th&gt;
&lt;th&gt;Notes&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Embedded Systems: Introduction To ARM Cortex-M Microcontrollers (5&lt;sup&gt;th&lt;/sup&gt; Ed.)&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;http://a.co/03pd6u0&#34;&gt;BOOK&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Computer Systems: A Programming Perspective, (2&lt;sup&gt;nd&lt;/sup&gt; Ed.)&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;http://a.co/7W4IMFZ&#34;&gt;BOOK&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;21&lt;sup&gt;st&lt;/sup&gt; Century C (2&lt;sup&gt;nd&lt;/sup&gt; Ed.)&lt;/td&gt;
&lt;td&gt;&lt;a href=&#34;http://a.co/jloJHt7&#34;&gt;BOOK&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</description>
    </item>
    
    <item>
      <title>Elixir/Erlang Resources</title>
      <link>http://noamswebsite.com/wiki-main/computers/elixir_resources/</link>
      <pubDate>Wed, 04 Jan 2017 16:11:51 -0500</pubDate>
      
      <guid>http://noamswebsite.com/wiki-main/computers/elixir_resources/</guid>
      <description>

&lt;h2 id=&#34;learning&#34;&gt;Learning&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Title&lt;/th&gt;
&lt;th&gt;Notes&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://a.co/hjRDstC&#34;&gt;Elixir In Action&lt;/a&gt; (book)&lt;/td&gt;
&lt;td&gt;My go-to recommendation for getting started with Elixir.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://medium.com/@diamondgfx/introduction-fe138ac6079d&#34;&gt;Writing A Blog Engine in Phoenix&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Great first tutorial for Phoenix framework&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://www.erlang-in-anger.com/&#34;&gt;Erlang In Anger&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Great guide for when stuff goes bad.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;memory-gc&#34;&gt;Memory / GC&lt;/h2&gt;

&lt;p&gt;For articles on GC / compilers in general see &lt;a href=&#34;http://noamswebsite.com/wiki-main/computers/compilers&#34;&gt;compilers&lt;/a&gt; section.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Title&lt;/th&gt;
&lt;th&gt;Notes&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://hamidreza-s.github.io/erlang/scheduling/real-time/preemptive/migration/2016/02/09/erlang-scheduler-details.html&#34;&gt;Erlang Scheduler Details and Why It Matters&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://hamidreza-s.github.io/erlang%20garbage%20collection%20memory%20layout%20soft%20realtime/2015/08/24/erlang-garbage-collection-details-and-why-it-matters.html&#34;&gt;Erlang Garbage Collection Details and Why It Matters&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Simple introduction to Erlang GC concepts. Start here.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://www.erlang-solutions.com/blog/erlang-19-0-garbage-collector.html&#34;&gt;Erlang 19.0 Garbage Collector&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://erlang.org/doc/efficiency_guide/introduction.html&#34;&gt;Erlang Efficiency Guide&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://blog.bugsense.com/post/74179424069/erlang-binary-garbage-collection-a-lovehate&#34;&gt;Erlang Binary Garbage Collection: A love/hate relationship&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;Some findings on the shared heap GC.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;concurrency&#34;&gt;Concurrency&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Title&lt;/th&gt;
&lt;th&gt;Notes&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://jlouisramblings.blogspot.ca/2013/01/how-erlang-does-scheduling.html?m=1&#34;&gt;How Erlang does scheduling&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://kth.diva-portal.org/smash/record.jsf?searchId=2&amp;amp;pid=diva2%3A392243&amp;amp;dswid=-8162&#34;&gt;Characterizing the Scalability of Erlang VM on Many-core Processors&lt;/a&gt; (pdf)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;performance&#34;&gt;Performance&lt;/h2&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Title&lt;/th&gt;
&lt;th&gt;Notes&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://www.evanmiller.org/elixir-ram-and-the-template-of-doom.html&#34;&gt;Elixir RAM And The Template Of Doom&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://www.bignerdranch.com/blog/elixir-and-io-lists-part-1-building-output-efficiently/&#34;&gt;Elixir and IO Lists, Part 1: Building Output Efficiently&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;performance-tips&#34;&gt;Performance Tips&lt;/h2&gt;

&lt;p&gt;Don&amp;rsquo;t have processes the many other processes depend on. For example, a
single-process cache that many others call to. This will be a bottleneck
because you&amp;rsquo;ll always have to wait for that process&amp;rsquo;s turn from the scheduler.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>React Resources</title>
      <link>http://noamswebsite.com/wiki-main/computers/react_resources/</link>
      <pubDate>Wed, 04 Jan 2017 14:41:18 -0500</pubDate>
      
      <guid>http://noamswebsite.com/wiki-main/computers/react_resources/</guid>
      <description>&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Title&lt;/th&gt;
&lt;th&gt;Format&lt;/th&gt;
&lt;th&gt;Notes&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;http://teropa.info/blog/2015/09/10/full-stack-redux-tutorial.html&#34;&gt;A Comprehensive Guide to Test-First Development with Redux, React, and Immutable&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;tutorial&lt;/td&gt;
&lt;td&gt;Great comprehensive introduction to the whole ecosystem.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://youtu.be/-jwQ3sGoiXg&#34;&gt;Redux, Re-fram, Relay, Om/next, oh my!&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;video&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;a href=&#34;https://github.com/absinthe-graphql/absinthe_relay/issues/8&#34;&gt;Setting Up Absinthe Relay In Elixir&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</description>
    </item>
    
    <item>
      <title>Separate Ecto From Phoenix In Umbrella App</title>
      <link>http://noamswebsite.com/wiki-main/computers/phoenix_no_ecto/</link>
      <pubDate>Wed, 04 Jan 2017 00:52:25 -0500</pubDate>
      
      <guid>http://noamswebsite.com/wiki-main/computers/phoenix_no_ecto/</guid>
      <description>

&lt;p&gt;First, create umbrella application:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ mix new --umbrella my_app
$ cd my_app/apps
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next create Phoenix app, excluding Ecto:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ mix phoenix.new web --no-ecto
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we create a new mix project for Ecto, with supervision tree:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ mix new db --sup
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally we need to set up some configuration files.&lt;/p&gt;

&lt;h2 id=&#34;setting-up-db-project&#34;&gt;Setting Up Db Project&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;$ cd db
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;First in the &lt;code&gt;db&lt;/code&gt; project (following the
&lt;a href=&#34;https://hexdocs.pm/ecto/getting-started.html&#34;&gt;getting started&lt;/a&gt; docs for Ecto:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;mix.exs&lt;/code&gt;&lt;/strong&gt; (note that we do not need to register &lt;code&gt;:ecto&lt;/code&gt; application)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  def application do
    [applications: [:logger, :postgrex],
     mod: {Db, []}]
  end

  defp deps do
    [{:postgrex, &amp;quot;~&amp;gt; 0.13.0&amp;quot;},
     {:ecto, &amp;quot;~&amp;gt; 2.1.1&amp;quot;}]
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Run configuration by running:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ mix ecto.gen.repo -r Db.Repo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will populate &lt;code&gt;lib/db/repo.ex&lt;/code&gt; and  &lt;code&gt;config.config.exs&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;lib/db.ex&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;children = [
  supervisor(Db.Repo, [])
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;optional&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;We probably want configs for multiple environments.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;config/config.exs&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Uncomment the last line, or replace the contents of the file with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use Mix.Config

config :db,
  ecto_repos: [Db.Repo]

# Import environment specific config. This must remain at the bottom
# of this file so it overrides the configuration defined above.
import_config &amp;quot;#{Mix.env}.exs&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will load environment-specific configs.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;config/dev.exs&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use Mix.Config

config :db, Db.Repo,
  adapter: Ecto.Adapters.Postgres,
  username: &amp;quot;foo&amp;quot;,
  database: &amp;quot;myproject_dev&amp;quot;,
  hostname: &amp;quot;localhost&amp;quot;,
  pool_size: 10
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;config/test.exs&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use Mix.Config

config :db, Db.Repo,
  adapter: Ecto.Adapters.Postgres,
  username: &amp;quot;foo&amp;quot;,
  password: &amp;quot;12345&amp;quot;,
  database: &amp;quot;myproject_test&amp;quot;,
  hostname: &amp;quot;localhost&amp;quot;,
  pool: Ecto.Adapters.SQL.Sandbox

config :logger,
  backends: [:console],
  compile_time_purge_level: :debug
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;set-up-phoenix-app&#34;&gt;Set Up Phoenix App&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;$ cd ../web
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;mix.exs&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  def application do
    [mod: {Web, []},
     applications: [:phoenix_ecto, :db]]
  end

  defp deps do
    [{:phoenix_ecto, &amp;quot;~&amp;gt; 3.2.1&amp;quot;},
     {:db, in_umbrella: true}]
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;config/config.exs&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;config :web,
  ecto_repos: [Db.Repo]

# Configure phoenix generators
config :phoenix, :generators,
  migration: false
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;notes&#34;&gt;Notes&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;From now on, when running &lt;code&gt;mix phoenix.gen.html&lt;/code&gt; or &lt;code&gt;mix phoenix.gen.json&lt;/code&gt;,
pass the &lt;code&gt;--no-model&lt;/code&gt; option. (&lt;strong&gt;update:&lt;/strong&gt; see question below.)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Since app is umbrella app now, remember to &lt;code&gt;cd&lt;/code&gt; into phoenix app directory
before running generators, or files will be generated at umbrella&amp;rsquo;s top level.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;questions&#34;&gt;Questions&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Is it there a way to make it so that there&amp;rsquo;s no need for &lt;code&gt;--no-model&lt;/code&gt; option
every time?&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;config :phoenix, :generators, model: false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Answer provided by the man himself :)
&lt;a href=&#34;https://elixirforum.com/t/should-we-separate-ecto-from-phoenix-in-umbrella-app/1515/22&#34;&gt;https://elixirforum.com/t/should-we-separate-ecto-from-phoenix-in-umbrella-app/1515/22&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Using The Same bashrc / zshrc Across Computers</title>
      <link>http://noamswebsite.com/wiki-main/computers/sync_bashrc/</link>
      <pubDate>Wed, 04 Jan 2017 00:19:02 -0500</pubDate>
      
      <guid>http://noamswebsite.com/wiki-main/computers/sync_bashrc/</guid>
      <description>&lt;p&gt;Here is a simple method I use to share the same &lt;code&gt;.bashrc&lt;/code&gt; / &lt;code&gt;.zshrc&lt;/code&gt; /
&lt;code&gt;.bash_profile&lt;/code&gt; on multiple computers, while still retaining unique
settings where I need them.&lt;/p&gt;

&lt;p&gt;Suppose you want some special setting to apply only to your linux laptop, but
not to your mac laptop.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ mkdir ~/configs
$ touch ~/.is_linux
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if [ -f &#39;.is_linux&#39; ]; then
    echo &amp;quot;This message only shows on my Linux laptops!&amp;quot;
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now with different config files you can configure different environments from
is single universal &lt;code&gt;*rc&lt;/code&gt; file you keep in a
&lt;a href=&#34;https://github.com/noam87/DOTfiles&#34;&gt;dotfiles&lt;/a&gt; repo.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s it. It&amp;rsquo;s not fancy, but it works.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Ecto Callbacks Macro</title>
      <link>http://noamswebsite.com/wiki-main/computers/ecto_callbacks/</link>
      <pubDate>Sat, 22 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>http://noamswebsite.com/wiki-main/computers/ecto_callbacks/</guid>
      <description>

&lt;p&gt;Ecto callbacks (before/after) commit hooks have been deprecated, for a
general good reason. Using callbacks is generally bad and you should never do
it. But sometimes you need to do it because real life.&lt;/p&gt;

&lt;p&gt;I wrote this macro this afternoon that implements both atomic and non-atomic
callbacks. Here it is in all its glory. I won&amp;rsquo;t make it a hex package because
it&amp;rsquo;s probably a bad thing to do.&lt;/p&gt;

&lt;h2 id=&#34;usage&#34;&gt;Usage&lt;/h2&gt;

&lt;p&gt;In your &lt;code&gt;YourProject.Model.ex&lt;/code&gt; file, add:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;defmodule MyProject.Model do
  defmacro __using__(_opts) do
    quote do
      use Ecto.Schema
      import Ecto.Changeset
      use MyProject.Hooks
    end

    @doc &amp;quot;&amp;quot;&amp;quot;
    Dumb. For piping together methods in an `atomic_after_*` function call.

    ## Example

      first_callback()
      |&amp;gt; hook_glue()
      |&amp;gt; second_callback()
    &amp;quot;&amp;quot;&amp;quot;
    def hook_glue({:ok, struct}), do: struct
    def hook_glue(struct), do: struct
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;implementation&#34;&gt;Implementation&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;defmodule MyProject.Hooks do
  @moduledoc &amp;quot;&amp;quot;&amp;quot;
  This module macro defines the following functions within the model,
  delegating to `Repo`, but allowing us to add `after_*` hooks,
  which are no longer supported in Ecto
  (http://blog.plataformatec.com.br/2015/12/ecto-v1-1-released-and-ecto-v2-0-plans/)

      delete,
      delete!,
      delete_all,
      insert,
      insert!,
      insert_all,
      insert_or_update,
      insert_or_update!,
      update,
      update!,
      update_all

  ## Hooks

  `after_*` will perform action after transaction is done.
  `atomic_after_*` will perform action within the same transaction, at the end.

  When using `atomic_after`, make sure to return the resulting struct in
  the success case, in its tuple format `{:ok, res}` or `{:error, error}`.

  The return value of the transaction is what will be returned by the action.

  ## Usage

  Will print console message after updating:

  **NOTE:** Remember to cover general case after.

      defmodule MyModel do
        use MyProject.Model # which calls `use MyProject.Overrides`

        defp after_update(result, changeset) do
          IO.puts(&amp;quot;updating!&amp;quot;)
        end

        defp atomic_after_update(r = {:error, _}, _), do: r
        defp atomic_after_update(res, ch) do
          case OtherModel.get!(1).name do
            &amp;quot;bob&amp;quot; -&amp;gt; Repo.rollback(:cant_update_if_name_is_bob)
            _ -&amp;gt; res
          end
        end

      end

      MyModel.update!(ch)
      # -&amp;gt; &amp;quot;updating!&amp;quot;
      %MyModel{...}
  &amp;quot;&amp;quot;&amp;quot;

  defmacro __using__(_) do
    actions = [:delete,
               :delete!,
               :delete_all,
               :insert,
               :insert!,
               :insert_all,
               :insert_or_update,
               :insert_or_update!,
               :update,
               :update!,
               :update_all]

    # For the love of God, do not touch until this is tested!
    quote do
      alias MyProject.Repo

      unquote do
        Enum.map(actions, fn action -&amp;gt;
          quote do
            def unquote(action)(changeset, opts \\ []) do
              fwd = fn -&amp;gt;
                res = Repo.unquote(action)(changeset, opts)
                after_res = unquote(:&amp;quot;atomic_after_#{action}&amp;quot;)(res, changeset)

                # Handle whether the action is with bang for or not
                unquote do
                  if String.last(Atom.to_string(action)) == &amp;quot;!&amp;quot; do
                    quote do
                      transaction_result =
                        case after_res do
                          {:ok, res} -&amp;gt; res
                          {:error, error} -&amp;gt; raise error
                        end
                    end
                  else
                    quote do
                      transaction_result = after_res
                    end
                  end
                end
                transaction_result
              end

              result =
                case Repo.transaction(fwd) do
                  # Covers e.g insert / update
                  {:ok, {:ok, res}} -&amp;gt; {:ok, res}
                  # Just in case
                  {:ok, {:error, error}} -&amp;gt; {:error, error}
                  # Covers insert! update! which return struct
                  {:ok, res} -&amp;gt; res
                  # Covers rollback which returns error
                  {:error, error} -&amp;gt; {:error, error}
                end

              unquote(:&amp;quot;after_#{action}&amp;quot;)(result, changeset)
              result
            end
          end
        end)
      end

      unquote do
        Enum.map(actions, fn action -&amp;gt;
          quote do
            defp unquote(:&amp;quot;after_#{action}&amp;quot;)(_res, _original_struct), do: nil
          end
        end)
      end

      unquote do
        Enum.map(actions, fn action -&amp;gt;
          if String.last(Atom.to_string(action)) == &amp;quot;!&amp;quot; do
            quote do
              defp unquote(:&amp;quot;atomic_after_#{action}&amp;quot;)(res, _) do
                {:ok, res}
              end
            end
          else
            quote do
              defp unquote(:&amp;quot;atomic_after_#{action}&amp;quot;)(res, _), do: res
            end
          end
        end)
      end

      defoverridable [after_delete: 2,
                      atomic_after_delete: 2,
                      after_delete!: 2,
                      atomic_after_delete!: 2,
                      after_delete_all: 2,
                      atomic_after_delete_all: 2,
                      after_insert: 2,
                      atomic_after_insert: 2,
                      after_insert!: 2,
                      atomic_after_insert!: 2,
                      after_insert_all: 2,
                      atomic_after_insert_all: 2,
                      after_insert_or_update: 2,
                      atomic_after_insert_or_update: 2,
                      after_insert_or_update!: 2,
                      atomic_after_insert_or_update!: 2,
                      after_update: 2,
                      atomic_after_update: 2,
                      after_update!: 2,
                      atomic_after_update!: 2,
                      after_update_all: 2,
                      atomic_after_update_all: 2]
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Amdahl&#39;s Law</title>
      <link>http://noamswebsite.com/wiki-main/computers/amdahls_law/</link>
      <pubDate>Sat, 05 Oct 2013 00:00:00 +0000</pubDate>
      
      <guid>http://noamswebsite.com/wiki-main/computers/amdahls_law/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;As multicore computing becomes the norm (even my phone is dual core!), it&amp;rsquo;s important to understand the benefits and also the limitations of concurrency. Amdahl&amp;rsquo;s Law addresses the latter.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Let&amp;rsquo;s imagine a simple program. It prints &amp;ldquo;Hello World&amp;rdquo; 100 times, then quits.&lt;/p&gt;

&lt;p&gt;Our first version of the program is written as a single sequential task: it prints one &amp;ldquo;Hello World&amp;rdquo;, then another, then another, 100 times, then quits.  This program takes some unit of time, $t$ to execute.&lt;/p&gt;

&lt;p&gt;Now say we have a dual-core machine at hand. (My phone, perhaps).&lt;/p&gt;

&lt;p&gt;Cool, now we can spawn &lt;em&gt;two&lt;/em&gt; tasks that print &amp;ldquo;Hello World&amp;rdquo; 50 times each. And, because our magical imaginary computer experiences no overhead, it takes us exactly $\frac{ t }{ 2 }$ units of time to run our second program.&lt;/p&gt;

&lt;p&gt;So we keep adding more and more processors, until we have 100 concurrent threads printing one &amp;ldquo;Hello World&amp;rdquo; each, and our program runs 100 times faster.&lt;/p&gt;

&lt;p&gt;At this point we stop: &amp;ldquo;Ah, the trend is clear: more processors equals more speed! No point in continuing this experiment.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;A naive (wrong) first guess:&lt;/strong&gt; Given $n$ processors executing a program, the maximum boost in speed is $n$. (That is, we can get our program to run $n$ times faster).&lt;/p&gt;

&lt;p&gt;Cool! This means that, given enough processors, we could make &lt;em&gt;any&lt;/em&gt; program run almost instantly. Right?&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://noamswebsite.com/img/more_cores.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;(&lt;a href=&#34;http://forums.pureoverclock.com/amd/21809-rumor-mill-amd-iv-x12-170-12-cores-24mb-cache-6ghz-2.html#post169754&#34;&gt;Pic original source&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;Of course this is not the case! Enough daydreaming. Let&amp;rsquo;s figure out a more  realistic estimate.&lt;/p&gt;

&lt;p&gt;Let $P$ be the proportion of our program that can run in parallel. Then it follows that $1 - P$ is the proportion that cannot be broken up into independent tasks.&lt;/p&gt;

&lt;p&gt;For example, since our program can be broken up into 100 independent tasks, then $1 - P = \frac{ 1 }{ 100 }$.&lt;/p&gt;

&lt;p&gt;It follows that the maximum boost in speed (denoted $S(n)$) that we can expect out of assigning concurrent tasks to $n$ parallel processors can be represented by the following equation:&lt;/p&gt;

&lt;p&gt;$$S(n) = \frac{ 1 }{ (1 - P) + \frac{ P }{ n } }$$&lt;/p&gt;

&lt;p&gt;This is, in fact, Amdahl&amp;rsquo;s equation.&lt;/p&gt;

&lt;p&gt;Uh-oh&amp;hellip; do you see it? As we add more and more processors to our computer, and $n \to \infty$, we are left with $ S =  \frac{ 1 }{ 1 - p }$.&lt;/p&gt;

&lt;p&gt;What we have here is a clear case of &lt;em&gt;diminishing returns.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;How bad is it?  Let&amp;rsquo;s add &lt;em&gt;one million cores&lt;/em&gt; to our imaginary computer, and measure its performance at $gc = 99\%$:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://noamswebsite.com/img/99pc.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Well, for our imaginary software, 99% of which can be parallelized, we can expect a maximum boost of $ S = 100$.&lt;/p&gt;

&lt;p&gt;What about a program with $gc = 90\%$?&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://noamswebsite.com/img/90pc.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s that same plateau again. But this time we&amp;rsquo;re only seeing a maximum performance boost of $S = 10$.&lt;/p&gt;

&lt;p&gt;By $gc = 50\% $, we&amp;rsquo;re down to a program that can only be boosted to run twice as fast no matter how much parallel processing your machine is capable of!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Final Note:&lt;/strong&gt; In fact, Amdahl&amp;rsquo;s Law is not exclusive to concurrency, but applies to &lt;em&gt;any&lt;/em&gt; speed-boosting strategy that only affects some portion of a program.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Rice&#39;s Theorem</title>
      <link>http://noamswebsite.com/wiki-main/computers/rices_theorem/</link>
      <pubDate>Tue, 16 Apr 2013 00:00:00 +0000</pubDate>
      
      <guid>http://noamswebsite.com/wiki-main/computers/rices_theorem/</guid>
      <description>

&lt;p&gt;Rice&amp;rsquo;s theorem can be stated thus:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Every non-trivial semantic property of a program is undecidable.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Before we prove the theorem, let&amp;rsquo;s break down that statement:&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;semantic-property&#34;&gt;&amp;ldquo;Semantic Property&amp;rdquo;&lt;/h3&gt;

&lt;p&gt;A ssemantic property is a property of the language, &lt;em&gt;not the machine that is
computing it&lt;/em&gt;. For example, this is a semantic property of a language:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;All strings in language $L$ are of the form $1^n0^n$.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This is not a semantic property:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;It takes my program $n$ steps to generate the first 100 strings in $L$.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Note the importance of differentiating between a semantic property and not:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The halting problem is actually decidable for
&lt;a href=&#34;https://en.wikipedia.org/wiki/Linear_bounded_automaton&#34;&gt;Linear Bouned Automata&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;non-trivial&#34;&gt;&amp;ldquo;Non-Trivial&amp;rdquo;&lt;/h3&gt;

&lt;p&gt;A trivial property is a property that either all languages have or no language
has. A non-trivial property is everything else.&lt;/p&gt;

&lt;h3 id=&#34;undecidable&#34;&gt;&amp;ldquo;Undecidable&amp;rdquo;&lt;/h3&gt;

&lt;p&gt;A program can either &lt;strong&gt;accept&lt;/strong&gt;, &lt;strong&gt;reject&lt;/strong&gt;, or &lt;strong&gt;run forever&lt;/strong&gt;. If a program
reaches an accept or reject state, we say it &lt;strong&gt;halts&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;There are two types of programs: &lt;strong&gt;recognizers&lt;/strong&gt; and &lt;strong&gt;deciders&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;A recognizer is a program that can only tell you with certainty when it has
succeeded to solve a problem (reached the accept state). It cannot always tell
you when it has failed (if it goes into an infinite loop, there is no way to
know if it&amp;rsquo;s in a loop, or if it&amp;rsquo;s just taking very long to solve the problem).&lt;/p&gt;

&lt;p&gt;A decider is a program that always reaches either accepts or rejects. That is,
you not only know when the problem was solved, but you also know when it was
&lt;em&gt;not&lt;/em&gt; solved.&lt;/p&gt;

&lt;p&gt;A language is &lt;strong&gt;recognizable&lt;/strong&gt; if there exists at least one program that can
recognize it. For example, the following program reconizes $L = \{&amp;ldquo;342&amp;rdquo;\}$ (the
language made up of only the string &amp;ldquo;342&amp;rdquo;):&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Read input.&lt;/li&gt;
&lt;li&gt;If input == &amp;ldquo;342&amp;rdquo; print &amp;ldquo;accept&amp;rdquo;.&lt;/li&gt;
&lt;li&gt;Else return to step 1.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;This program &lt;em&gt;recognizes&lt;/em&gt; $L$, but it does not &lt;em&gt;decide&lt;/em&gt; $L$: if the input is in
$L$, it accepts, but if it&amp;rsquo;s not, then it will run forever, and you will never
know whether the input was not in $L$ or the program is just taking a long
time.&lt;/p&gt;

&lt;p&gt;A language is &lt;strong&gt;decidable&lt;/strong&gt; if there exists a program that can decide it. All
decidable languages are also recognizable. Here is a program that decides $L$:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Read input.&lt;/li&gt;
&lt;li&gt;If input == &amp;ldquo;342&amp;rdquo; print &amp;ldquo;accept&amp;rdquo;.&lt;/li&gt;
&lt;li&gt;Else print &amp;ldquo;input rejected&amp;rdquo;.&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;the-halting-problem&#34;&gt;The Halting Problem&lt;/h2&gt;

&lt;p&gt;Take the following language:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;$HALT_{ TM } = \{ \langle M, w \rangle | M$
is a program and $M$ halts on input $w \}$&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Remember, a program is itself just a string: any program can be written down as
a description, say an &lt;code&gt;.rb&lt;/code&gt; file, and that file can be used as an input for
another program (or itself!). So $HALT_{ TM }$ is a language that consists of
all programs $M$ and inputs $w$ such that $M$ halts on $w$.&lt;/p&gt;

&lt;p&gt;I won&amp;rsquo;t prove it in this post, but, as it turns out, $HALT_{ TM }$ is
undecidable. Meaning it is not possible to write a program that decides whether
an algorithm halts.&lt;/p&gt;

&lt;p&gt;With this in mind, we can finally prove Rice&amp;rsquo;s theorem:&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;rice-s-theorem&#34;&gt;Rice&amp;rsquo;s Theorem&lt;/h2&gt;

&lt;p&gt;Recall the theorem:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Every non-trivial semantic property of a program is undecidable.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Yet another way of stating this is as follows:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The language $P_{ TM }$, described below, is undecidable:
$P_{ TM } = \{ \langle M \rangle | M$ is a program and $L(M)$ has
non-trivial property $P \}$. Where $L(M)$ means &amp;ldquo;The language of $M$&amp;rdquo;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;So, for example, it is not possible to write a program $R $ that takes as its
input another program $M$ and decides whether the language of $M$ is regular
(that is, if $M$ can be simplified and represented as a finite automation).&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;proof&#34;&gt;Proof&lt;/h2&gt;

&lt;p&gt;We can prove Rice&amp;rsquo;s theorem by contradiction. We will show that &lt;strong&gt;if&lt;/strong&gt; $P_{ TM
}$ is decidable &lt;strong&gt;then&lt;/strong&gt; so is $HALT_{ TM }$.  Since we know that $ HALT_{ TM
}$ is undecidable, then $P_{ TM }$ must be undecidable too.&lt;/p&gt;

&lt;p&gt;Assume that $P$ is some non-trivial semantic property and that it is possible
to write a program $R$ that decides $P_{ TM }$. Here is how we could solve the
halting problem with that program:&lt;/p&gt;

&lt;p&gt;First, we write a program $T$ such that $\langle T \rangle $ is in $P_{ TM }$.
Because $P$ is non-trivial, such a program must exist.&lt;/p&gt;

&lt;p&gt;Take input $\langle M, w \rangle$ and use it to write a program $M_w$that
takes $x$ as its input and does the following:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;$M_w $:&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Run $M$ on input $w$. If $M$ halts, move on to step 2.  2. Run $T$ on $x$. Accept if $T$ accepts, and reject if $T$ rejects.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Here&amp;rsquo;s the clever part. &lt;em&gt;We don&amp;rsquo;t actually have to run $M_w$&lt;/em&gt;:&lt;/p&gt;

&lt;p&gt;All we need to know is that, if we &lt;em&gt;were&lt;/em&gt; to run $M_w$, there are two possible
outcomes:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;$M$ halts on input $w$, in which case $M_w$ reaches step 2.&lt;/li&gt;
&lt;li&gt;$M$ never halts and never reaches step 2.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;But note that, if $M$ halts on $w$, then step 2 is simply to run $T$, which
means that &lt;strong&gt;when $M$ halts on $w$, $ \langle M_w \rangle$is in $ P_{ TM
}$.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;So, if we were to run $R$ with input $\langle M_w \rangle$, it would be able
to tell us whether it is in $P_{ TM }$, and that in turn would tell us if $M$
halts on $w$.&lt;/p&gt;

&lt;p&gt;But this would mean that we could solve the halting problem, which we know  is
not possible.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>